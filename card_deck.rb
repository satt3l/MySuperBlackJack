# NOTE: файлик лучше назвать также как класс. Это не обязательно, но удобно.
class Deck
  attr_reader :cards, :cards_out

  def initialize(multiplier = 1)
    @cards = []
    @cards_out = []
    # NOTE: если мы хотим создать 2 или более колод, это должны быть два объекта класса `Deck`.
    # сейчас мы просто удваиваем каждую карту в одной колоде, но судя по настройке в правилах `card_deck_count` имеется в виду именно количество колод.
    multiplier.times do
      ['+', '<3', '^', '<>'].each do |suit|
        # NOTE: здесь можно было сделать вложенный цикл по номиналу карт.
        # NOTE: стоит также каждую карту представить объектом класса `Card`.
        (2..10).each { |n| @cards << {name: "#{n}#{suit}", value: n}}
        @cards << {name: "K#{suit}", value: 10}
        @cards << {name: "Q#{suit}", value: 10}
        @cards << {name: "J#{suit}", value: 10}
        @cards << {name: "A#{suit}", value: [11, 1]}
      end
    end
  end

  def get_card
    flush if @cards.empty?
    # NOTE: в `rand` можно передавать диапазон: `rand(1..10)`
    card = @cards.delete_at(rand(@cards.size - 1))
    @cards_out.push(card)
    # NOTE: `return` здесь не нужен, возвращается последнее значение выражения в методе.
    return card
  end

  def flush
    # NOTE: если это метод сброса колоды, почему мы в `@cards` присваиваем ссылку на объект вышедших карт `@cards_out`? Вообще, я бы не стал держать 2 переменные для карт колоды которые есть и которые вышли. Мы всегда можем воссоздать колоду заново, поскольку знаем какие у нас масти и номиналы карт (это кстати стоит поместить в константы). Таким образом, мы можем держать массив `@cards` где каждым элементом будет объект класса `Card`, а при вытягивании карты делать `@cards.pop`. Если же нам нужно будет сбросить колоду, мы всегда сможем заново сгенерировать массив `@cards`.
    @cards = self.cards_out
    @cards_out = []
  end

end
